#!/usr/bin/env dart
// Build script for white-label Flutter app
// Usage: dart run tool/build_app.dart <config_file> [--dev|--release]

import 'dart:io';
import 'dart:convert';
import 'package:yaml/yaml.dart';
import 'package:path/path.dart' as path;

void main(List<String> args) async {
  if (args.isEmpty) {
    print('Usage: dart run tool/build_app.dart <config_file> [--dev|--release]');
    print('Example: dart run tool/build_app.dart configs/melb2026.yaml --release');
    exit(1);
  }

  final configFile = args.first;
  final isDev = args.contains('--dev');
  final isRelease = args.contains('--release') || !isDev;

  print('üöÄ Building Evento app...');
  print('üìÑ Config: $configFile');
  print('üîß Mode: ${isDev ? "DEV" : "RELEASE"}');

  // Load config
  final config = await loadConfig(configFile);
  final eventName = path.basenameWithoutExtension(configFile);

  // Validate required fields
  validateConfig(config, eventName);

  // Generate app_config.g.dart
  await generateAppConfig(config);

  // Download assets if URLs provided
  if (config['icon_url'] != null) {
    await downloadAsset(config['icon_url'], 'assets/generated/icon.png');
  }
  if (config['splash_url'] != null) {
    await downloadAsset(config['splash_url'], 'assets/generated/splash.png');
  }

  // Download Firebase config files
  if (config['firebase_android_url'] != null) {
    await downloadAsset(
      config['firebase_android_url'],
      'android/app/google-services.json',
    );
  }
  if (config['firebase_ios_url'] != null) {
    await downloadAsset(
      config['firebase_ios_url'],
      'ios/Runner/GoogleService-Info.plist',
    );
  }

  // Verify Firebase Analytics is enabled
  await verifyFirebaseAnalytics();

  // Handle Android signing configuration
  await handleAndroidSigning(config, isRelease);

  // Clean old icons before generating new ones
  await cleanOldIcons();

  // Generate icon and splash config files
  await generateIconConfig();
  await generateSplashConfig();

  // Run Flutter packages to generate icons and splash screens
  print('üé® Generating app icons...');
  await runFlutterLauncherIcons();

  // Fix: flutter_launcher_icons sometimes doesn't create Contents.json for iOS
  await generateIOSIconContentsJson();

  print('üé® Generating splash screens...');
  await runFlutterNativeSplash();

  // Update Android config
  await updateAndroidConfig(config, eventName);

  // Update iOS config
  await updateIOSConfig(config, eventName);

  // Update iOS APNs environment based on dev/release mode
  await updateIOSAPNsEnvironment(isRelease);

  print('‚úÖ Configuration complete!');

  if (isRelease) {
    print('üì¶ Building release artifacts...');
    await buildRelease(eventName);
  } else {
    print('üéØ Ready for dev mode! Run: flutter run');
  }
}

Future<Map<String, dynamic>> loadConfig(String configFile) async {
  final file = File(configFile);
  if (!await file.exists()) {
    print('‚ùå Config file not found: $configFile');
    exit(1);
  }

  final content = await file.readAsString();
  final yaml = loadYaml(content);
  return Map<String, dynamic>.from(yaml);
}

void validateConfig(Map<String, dynamic> config, String eventName) {
  final required = [
    'app_name',
    'bundle_name',
    'app_id',
    'onesignal_id',
    'android_bundle_id',
    'ios_bundle_id',
    'icon_url',
    'splash_url',
    'firebase_android_url',
    'firebase_ios_url',
  ];

  // For release builds, Android signing is required
  // (We'll check this later in the build process, not here)

  final missing = <String>[];
  for (final field in required) {
    if (config[field] == null || config[field].toString().isEmpty) {
      missing.add(field);
    }
  }

  // Check event configuration (need either single or multi event)
  final hasSingleEvent = config['single_event_url'] != null && 
                         config['single_event_id'] != null;
  final hasMultiEvent = config['multi_event_list_url'] != null && 
                        config['multi_event_list_id'] != null;

  if (!hasSingleEvent && !hasMultiEvent) {
    missing.add('single_event_url + single_event_id OR multi_event_list_url + multi_event_list_id');
  }

  if (missing.isNotEmpty) {
    print('‚ùå Missing required configuration fields:');
    for (final field in missing) {
      print('   - $field');
    }
    print('\nüí° See config.template.yaml for an example configuration.');
    exit(1);
  }

  print('‚úÖ Configuration validated');
}

Future<void> generateAppConfig(Map<String, dynamic> config) async {
  final output = StringBuffer();
  output.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  output.writeln('// This file is generated by tool/build_app.dart');
  output.writeln('// Run: dart run tool/build_app.dart <config_file>');
  output.writeln('');
  output.writeln("import 'package:flutter/material.dart';");
  output.writeln('');
  output.writeln('class AppConfig {');
  output.writeln('  final String appName;');
  output.writeln('  final String oneSignalId;');
  output.writeln('  final String? singleEventUrl;');
  output.writeln('  final String? singleEventId;');
  output.writeln('  final String? multiEventListUrl;');
  output.writeln('  final String? multiEventListId;');
  output.writeln('  final int? appId;');
  output.writeln('  final String? splashImage;');
  output.writeln('  final bool? isTimer;');
  output.writeln('  final int? searchbarcolorR;');
  output.writeln('  final int? searchbarcolorG;');
  output.writeln('  final int? searchbarcolorB;');
  output.writeln('  final double? searchbarcolorA;');
  output.writeln('');
  output.writeln('  AppConfig({');
  output.writeln('    required this.appName,');
  output.writeln('    required this.oneSignalId,');
  output.writeln('    this.singleEventUrl,');
  output.writeln('    this.singleEventId,');
  output.writeln('    this.multiEventListUrl,');
  output.writeln('    this.multiEventListId,');
  output.writeln('    this.appId,');
  output.writeln('    this.splashImage,');
  output.writeln('    this.isTimer,');
  output.writeln('    this.searchbarcolorR,');
  output.writeln('    this.searchbarcolorG,');
  output.writeln('    this.searchbarcolorB,');
  output.writeln('    this.searchbarcolorA,');
  output.writeln('  });');
  output.writeln('');
  output.writeln('  Color? get searchbarcolor {');
  output.writeln('    if (searchbarcolorR != null &&');
  output.writeln('        searchbarcolorG != null &&');
  output.writeln('        searchbarcolorB != null &&');
  output.writeln('        searchbarcolorA != null) {');
  output.writeln('      return Color.fromRGBO(');
  output.writeln('        searchbarcolorR!,');
  output.writeln('        searchbarcolorG!,');
  output.writeln('        searchbarcolorB!,');
  output.writeln('        searchbarcolorA!,');
  output.writeln('      );');
  output.writeln('    }');
  output.writeln('    return null;');
  output.writeln('  }');
  output.writeln('}');
  output.writeln('');

  // Generate appConfig instance
  output.writeln('final appConfig = AppConfig(');
  output.writeln("  appName: '${escapeString(config['app_name'] ?? 'Evento App')}',");
  output.writeln("  oneSignalId: '${escapeString(config['onesignal_id'] ?? '')}',");

  if (config['single_event_url'] != null) {
    output.writeln("  singleEventUrl: '${escapeString(config['single_event_url'])}',");
  }
  if (config['single_event_id'] != null) {
    output.writeln("  singleEventId: '${escapeString(config['single_event_id'])}',");
  }
  if (config['multi_event_list_url'] != null) {
    output.writeln("  multiEventListUrl: '${escapeString(config['multi_event_list_url'])}',");
  }
  if (config['multi_event_list_id'] != null) {
    output.writeln("  multiEventListId: '${escapeString(config['multi_event_list_id'])}',");
  }
  if (config['app_id'] != null) {
    output.writeln('  appId: ${config['app_id']},');
  }
  if (config['splash_image'] != null) {
    output.writeln("  splashImage: '${escapeString(config['splash_image'])}',");
  } else if (config['splash_url'] != null) {
    output.writeln("  splashImage: 'assets/generated/splash.png',");
  }
  if (config['is_timer'] != null) {
    output.writeln('  isTimer: ${config['is_timer']},');
  }
  if (config['searchbar_color'] != null) {
    final color = config['searchbar_color'];
    if (color is Map) {
      output.writeln('  searchbarcolorR: ${color['r'] ?? 0},');
      output.writeln('  searchbarcolorG: ${color['g'] ?? 0},');
      output.writeln('  searchbarcolorB: ${color['b'] ?? 0},');
      output.writeln('  searchbarcolorA: ${color['a'] ?? 1.0},');
    }
  }
  output.writeln(');');

  final outputFile = File('lib/app_config.g.dart');
  await outputFile.writeAsString(output.toString());
  print('‚úÖ Generated lib/app_config.g.dart');
}

String escapeString(String str) {
  return str.replaceAll("'", "\\'").replaceAll('\n', '\\n');
}

Future<void> downloadAsset(String url, String destination) async {
  print('üì• Downloading $url to $destination...');
  try {
    final client = HttpClient();
    try {
      final request = await client.getUrl(Uri.parse(url));
      final response = await request.close();
      final bytes = await response.expand((chunk) => chunk).toList();
      final file = File(destination);
      await file.create(recursive: true);
      await file.writeAsBytes(bytes);
      print('‚úÖ Downloaded $destination');
    } finally {
      client.close();
    }
  } catch (e) {
    print('‚ö†Ô∏è  Failed to download $url: $e');
  }
}

Future<void> verifyFirebaseAnalytics() async {
  print('üîç Verifying Firebase Analytics configuration...');

  var analyticsEnabled = true;
  var warnings = <String>[];

  // Check Android google-services.json
  final androidConfigFile = File('android/app/google-services.json');
  if (await androidConfigFile.exists()) {
    try {
      final content = await androidConfigFile.readAsString();
      final json = jsonDecode(content);

      // Verify package name matches
      final packageName = json['client']?[0]?['client_info']?['android_client_info']?['package_name'];
      if (packageName != null) {
        print('  ‚úÖ Android package name: $packageName');
      }

      // Check if project has Analytics (google-services.json doesn't have explicit flag)
      final projectId = json['project_info']?['project_id'];
      if (projectId != null) {
        print('  ‚úÖ Android Firebase project: $projectId');
      }
    } catch (e) {
      warnings.add('Failed to parse android/app/google-services.json: $e');
      analyticsEnabled = false;
    }
  } else {
    warnings.add('Android google-services.json not found');
    analyticsEnabled = false;
  }

  // Check iOS GoogleService-Info.plist
  final iosConfigFile = File('ios/Runner/GoogleService-Info.plist');
  if (await iosConfigFile.exists()) {
    try {
      final content = await iosConfigFile.readAsString();

      // Check bundle ID
      final bundleIdMatch = RegExp(r'<key>BUNDLE_ID</key>\s*<string>([^<]+)</string>').firstMatch(content);
      if (bundleIdMatch != null) {
        print('  ‚úÖ iOS bundle ID: ${bundleIdMatch.group(1)}');
      }

      // Check if Analytics is enabled
      final analyticsMatch = RegExp(r'<key>IS_ANALYTICS_ENABLED</key>\s*<(true|false)>').firstMatch(content);
      if (analyticsMatch != null) {
        final isEnabled = analyticsMatch.group(1) == 'true';
        if (isEnabled) {
          print('  ‚úÖ iOS Firebase Analytics: ENABLED');
        } else {
          print('  ‚ö†Ô∏è  iOS Firebase Analytics: DISABLED');
          warnings.add('Firebase Analytics is DISABLED for iOS in GoogleService-Info.plist');
          warnings.add('   ‚Üí Enable it in Firebase Console: https://console.firebase.google.com/');
          warnings.add('   ‚Üí Go to Project Settings ‚Üí iOS app ‚Üí Enable Analytics');
          analyticsEnabled = false;
        }
      }

      // Check project ID
      final projectIdMatch = RegExp(r'<key>PROJECT_ID</key>\s*<string>([^<]+)</string>').firstMatch(content);
      if (projectIdMatch != null) {
        print('  ‚úÖ iOS Firebase project: ${projectIdMatch.group(1)}');
      }
    } catch (e) {
      warnings.add('Failed to parse ios/Runner/GoogleService-Info.plist: $e');
      analyticsEnabled = false;
    }
  } else {
    warnings.add('iOS GoogleService-Info.plist not found');
    analyticsEnabled = false;
  }

  if (warnings.isNotEmpty) {
    print('\n‚ö†Ô∏è  Firebase Configuration Warnings:');
    for (final warning in warnings) {
      print('   $warning');
    }
    print('');
  }

  if (analyticsEnabled) {
    print('‚úÖ Firebase Analytics verification complete - all platforms enabled\n');
  } else {
    print('‚ö†Ô∏è  Firebase Analytics verification complete - issues found (see above)\n');
  }
}

Future<void> handleAndroidSigning(Map<String, dynamic> config, bool isRelease) async {
  // For release builds, signing is required
  if (isRelease) {
    final hasKeyPropertiesUrl = config['key_properties_url'] != null;
    final hasIndividualFields = config['key_store_password'] != null &&
        config['key_password'] != null &&
        config['key_alias'] != null &&
        config['keystore_file_url'] != null;

    if (!hasKeyPropertiesUrl && !hasIndividualFields) {
      print('‚ö†Ô∏è  Warning: No Android signing configuration found for release build');
      print('   Add either key_properties_url or individual signing fields to config');
    }
  }

  // Option 1: Download key.properties from URL
  if (config['key_properties_url'] != null) {
    await downloadAsset(
      config['key_properties_url'],
      'android/key.properties',
    );
    print('‚úÖ Downloaded key.properties');
  }
  // Option 2: Generate key.properties from individual fields
  else if (config['key_store_password'] != null &&
      config['key_password'] != null &&
      config['key_alias'] != null) {
    String keystorePath;
    
    // Handle keystore file - can be URL (download) or local path (use directly)
    if (config['keystore_file_url'] != null) {
      final keystoreUrlOrPath = config['keystore_file_url'] as String;
      
      // Check if it's a URL (starts with http:// or https://) or local path
      if (keystoreUrlOrPath.startsWith('http://') || 
          keystoreUrlOrPath.startsWith('https://')) {
        // It's a URL - download it (NOT RECOMMENDED for production)
        print('‚ö†Ô∏è  WARNING: Downloading keystore from URL is NOT secure!');
        print('   Keystore files should be stored locally, not in cloud storage.');
        keystorePath = 'android/app/keystore.jks';
        await downloadAsset(keystoreUrlOrPath, keystorePath);
        print('‚úÖ Downloaded keystore file (INSECURE - use local path instead)');
      } else {
        // It's a local file path - use it directly
        // Unescape any escaped spaces or characters in the path
        keystorePath = keystoreUrlOrPath.replaceAll('\\ ', ' ').replaceAll('\\~', '~');
        final keystoreFile = File(keystorePath);
        if (!await keystoreFile.exists()) {
          if (isRelease) {
            print('‚ùå Keystore file not found: $keystorePath');
            print('   Please check the path in your config file.');
            exit(1);
          } else {
            print('‚ö†Ô∏è  Keystore file not found: $keystorePath');
            print('   Skipping signing configuration for dev build.');
            return; // Skip signing for dev builds if file doesn't exist
          }
        }
        print('‚úÖ Using local keystore file: $keystorePath');
      }
    } else {
      // Default to android/app/keystore.jks if no path provided
      keystorePath = 'android/app/keystore.jks';
      print('‚ö†Ô∏è  No keystore path provided, defaulting to: $keystorePath');
    }

    // Generate key.properties file
    final keyProperties = StringBuffer();
    keyProperties.writeln('storePassword=${config['key_store_password']}');
    keyProperties.writeln('keyPassword=${config['key_password']}');
    keyProperties.writeln('keyAlias=${config['key_alias']}');
    // Use absolute path for storeFile
    final keystoreFile = File(keystorePath);
    final absoluteKeystorePath = keystoreFile.absolute.path;
    // Escape spaces in path if needed
    final escapedPath = absoluteKeystorePath.replaceAll(' ', '\\ ');
    keyProperties.writeln('storeFile=$escapedPath');

    final keyPropertiesFile = File('android/key.properties');
    await keyPropertiesFile.writeAsString(keyProperties.toString());
    print('‚úÖ Generated key.properties from config');
  }
}

Future<void> updateAndroidConfig(Map<String, dynamic> config, String eventName) async {
  final buildGradle = File('android/app/build.gradle');
  if (!await buildGradle.exists()) {
    print('‚ö†Ô∏è  Android build.gradle not found, skipping Android config');
    return;
  }

  var content = await buildGradle.readAsString();
  final bundleId = config['android_bundle_id'] ?? 'nz.netproject.eventotracker.$eventName';
  final appName = config['app_name'] ?? 'Evento App';
  final bundleName = config['bundle_name'] ?? appName;
  
  // Use bundle_name for Android manifest label
  final manifestLabel = bundleName;

  // Update version if provided in config
  final versionName = config['version_name'];
  final versionCode = config['version_code'];
  
  if (versionName != null) {
    // Update versionName in build.gradle
    content = content.replaceAll(
      RegExp(r"flutterVersionName = localProperties\.getProperty\('flutter\.versionName'\)"),
      "flutterVersionName = localProperties.getProperty('flutter.versionName') ?: '$versionName'",
    );
  }
  
  if (versionCode != null) {
    // Update versionCode in build.gradle
    content = content.replaceAll(
      RegExp(r"flutterVersionCode = localProperties\.getProperty\('flutter\.versionCode'\)"),
      "flutterVersionCode = localProperties.getProperty('flutter.versionCode') ?: '$versionCode'",
    );
  }

  // Update namespace/applicationId
  content = content.replaceAll(
    RegExp(r'namespace\s+"[^"]+"'),
    'namespace "$bundleId"',
  );
  content = content.replaceAll(
    RegExp(r'applicationId\s+"[^"]+"'),
    'applicationId "$bundleId"',
  );

  // Update signing configuration if key.properties exists
  final keyPropertiesFile = File('android/key.properties');
  if (await keyPropertiesFile.exists()) {
    // Add signing config loading
    if (!content.contains('def keystoreProperties')) {
      final signingConfig = '''
def keystoreProperties = new Properties()
def keystorePropertiesFile = rootProject.file('key.properties')
if (keystorePropertiesFile.exists()) {
    keystorePropertiesFile.withReader('UTF-8') { reader ->
        keystoreProperties.load(reader)
    }
}

''';
      // Insert after flutterVersionName line
      // Match: def flutterVersionName = localProperties.getProperty('flutter.versionName')
      content = content.replaceFirst(
        RegExp(r'(def flutterVersionName = localProperties\.getProperty\([^\n]*\n)'),
        '\$1$signingConfig',
      );
    }

    // Add signing configs block if it doesn't exist
    if (!content.contains('signingConfigs {')) {
      final signingConfigs = '''
    signingConfigs {
        release {
            keyAlias keystoreProperties['keyAlias']
            keyPassword keystoreProperties['keyPassword']
            storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null
            storePassword keystoreProperties['storePassword']
        }
    }

''';
      // Insert after defaultConfig block, before buildTypes
      content = content.replaceFirst(
        RegExp(r'(\s+)\}\s+buildTypes'),
        '\$1}\n\n$signingConfigs    buildTypes',
      );
    }

    // Update release buildType to use signing config
    content = content.replaceAll(
      RegExp(r'signingConfig signingConfigs\.debug'),
      'signingConfig signingConfigs.release',
    );
  }

  await buildGradle.writeAsString(content);
  print('‚úÖ Updated Android config (bundle ID: $bundleId)');

  // Update strings.xml with bundle_name from YAML config
  // This is the Android way: manifest uses @string/app_name, which references strings.xml
  // The value in strings.xml is dynamically set from YAML bundle_name during build
  final stringsXml = File('android/app/src/main/res/values/strings.xml');
  if (await stringsXml.exists()) {
    var stringsContent = await stringsXml.readAsString();
    
    // Update app_name string resource with bundle_name from YAML
    stringsContent = stringsContent.replaceAll(
      RegExp(r'<string name="app_name">[^<]*</string>'),
      '<string name="app_name">$manifestLabel</string>',
    );
    
    await stringsXml.writeAsString(stringsContent);
    print('‚úÖ Updated strings.xml with bundle_name from YAML: $manifestLabel');
  } else {
    // Create strings.xml if it doesn't exist, populated from YAML bundle_name
    final stringsContent = '''<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">$manifestLabel</string>
</resources>
''';
    await stringsXml.create(recursive: true);
    await stringsXml.writeAsString(stringsContent);
    print('‚úÖ Created strings.xml with bundle_name from YAML: $manifestLabel');
  }

  // Update AndroidManifest.xml - ensure it uses @string/app_name
  final manifestFiles = [
    'android/app/src/main/AndroidManifest.xml',
    'android/app/src/debug/AndroidManifest.xml',
    'android/app/src/profile/AndroidManifest.xml',
  ];

  for (final manifestPath in manifestFiles) {
    final manifest = File(manifestPath);
    if (await manifest.exists()) {
      var manifestContent = await manifest.readAsString();
      
      // Ensure manifest uses @string/app_name (not hardcoded value)
      if (!manifestContent.contains('android:label="@string/app_name"')) {
        // Replace any hardcoded label with string resource reference
        manifestContent = manifestContent.replaceAll(
          RegExp(r'android:label\s*=\s*"[^"]*"'),
          'android:label="@string/app_name"',
        );
        await manifest.writeAsString(manifestContent);
        print('‚úÖ Updated $manifestPath to use @string/app_name');
      }
      
      // Add or update package attribute in manifest tag if it exists
      if (manifestContent.contains('package=')) {
        manifestContent = manifestContent.replaceAll(
          RegExp(r'package\s*=\s*"[^"]*"'),
          'package="$bundleId"',
        );
        await manifest.writeAsString(manifestContent);
      }
    }
  }
}

Future<void> updateIOSConfig(Map<String, dynamic> config, String eventName) async {
  final infoPlist = File('ios/Runner/Info.plist');
  if (!await infoPlist.exists()) {
    print('‚ö†Ô∏è  iOS Info.plist not found, skipping iOS config');
    return;
  }

  final bundleId = config['ios_bundle_id'] ?? 'nz.netproject.eventotracker.$eventName';
  final appName = config['app_name'] ?? 'Evento App';
  final bundleName = config['bundle_name'] ?? appName;
  final versionName = config['version_name'];
  final versionCode = config['version_code'];

  // Update Info.plist
  var content = await infoPlist.readAsString();
  
  // CFBundleName is the short bundle name (used internally)
  // Match with flexible whitespace handling (tabs, newlines, spaces)
  content = content.replaceAll(
    RegExp(r'<key>CFBundleName</key>\s*<string>[^<]*</string>', multiLine: true),
    '<key>CFBundleName</key>\n\t<string>$bundleName</string>',
  );
  
  // If CFBundleName doesn't exist, add it before CFBundleDisplayName
  if (!content.contains('<key>CFBundleName</key>')) {
    content = content.replaceFirst(
      RegExp(r'(<key>CFBundleDisplayName</key>)'),
      '<key>CFBundleName</key>\n\t<string>$bundleName</string>\n\t\$1',
    );
  }
  
  // CFBundleDisplayName is the display name (shown to users under the app icon)
  content = content.replaceAll(
    RegExp(r'<key>CFBundleDisplayName</key>\s*<string>[^<]*</string>', multiLine: true),
    '<key>CFBundleDisplayName</key>\n\t<string>$bundleName</string>',
  );
  
  // Update CFBundleIdentifier if it exists
  if (content.contains('<key>CFBundleIdentifier</key>')) {
    content = content.replaceAll(
      RegExp(r'<key>CFBundleIdentifier</key>\s*<string>[^<]+</string>'),
      '<key>CFBundleIdentifier</key>\n\t<string>$bundleId</string>',
    );
  }
  
  // Update version if provided
  if (versionName != null) {
    // CFBundleShortVersionString (version name)
    if (content.contains('<key>CFBundleShortVersionString</key>')) {
      content = content.replaceAll(
        RegExp(r'<key>CFBundleShortVersionString</key>\s*<string>[^<]+</string>'),
        '<key>CFBundleShortVersionString</key>\n\t<string>$versionName</string>',
      );
    }
  }
  
  // Update build number (CFBundleVersion) if provided
  if (versionCode != null) {
    // CFBundleVersion (build number - must increment for each App Store submission)
    if (content.contains('<key>CFBundleVersion</key>')) {
      content = content.replaceAll(
        RegExp(r'<key>CFBundleVersion</key>\s*<string>[^<]+</string>'),
        '<key>CFBundleVersion</key>\n\t<string>$versionCode</string>',
      );
    } else {
      // Add CFBundleVersion if it doesn't exist (insert before closing </dict>)
      content = content.replaceFirst(
        RegExp(r'(</dict>\s*</plist>)'),
        '\t<key>CFBundleVersion</key>\n\t<string>$versionCode</string>\n\$1',
      );
    }
  }

  await infoPlist.writeAsString(content);
  print('‚úÖ Updated iOS config (bundle ID: $bundleId, display name: $bundleName)');

  // Update project.pbxproj bundle identifier
  final projectFile = File('ios/Runner.xcodeproj/project.pbxproj');
  if (await projectFile.exists()) {
    var projectContent = await projectFile.readAsString();
    projectContent = projectContent.replaceAll(
      RegExp(r'PRODUCT_BUNDLE_IDENTIFIER = [^;]+;'),
      'PRODUCT_BUNDLE_IDENTIFIER = $bundleId;',
    );
    await projectFile.writeAsString(projectContent);
  }
  
  // Warn about iOS bundle ID registration requirement
  print('');
  print('‚ö†Ô∏è  iOS Bundle ID Registration Required:');
  print('   Bundle ID: $bundleId');
  print('   Before running on device, register this bundle ID in Apple Developer Portal:');
  print('   1. Go to https://developer.apple.com/account/resources/identifiers/list');
  print('   2. Create new App ID with bundle ID: $bundleId');
  print('   3. Enable: Push Notifications, Associated Domains');
  print('   4. Register your device UDID if needed');
  print('   Or open Xcode and let it auto-register: open ios/Runner.xcworkspace');
  print('');
}

Future<void> updateIOSAPNsEnvironment(bool isRelease) async {
  final entitlementsFile = File('ios/Runner/Runner.entitlements');
  if (!await entitlementsFile.exists()) {
    print('‚ö†Ô∏è  iOS entitlements file not found, skipping APNs environment update');
    return;
  }

  var content = await entitlementsFile.readAsString();
  final apnsEnvironment = isRelease ? 'production' : 'development';

  // Update aps-environment
  content = content.replaceAll(
    RegExp(r'<key>aps-environment</key>\s*<string>[^<]+</string>'),
    '<key>aps-environment</key>\n\t<string>$apnsEnvironment</string>',
  );

  await entitlementsFile.writeAsString(content);
  print('‚úÖ Updated iOS APNs environment to: $apnsEnvironment');
}

Future<void> cleanOldIcons() async {
  print('üßπ Cleaning old icons...');
  
  // Clean Android icons
  final androidResDir = Directory('android/app/src/main/res');
  if (await androidResDir.exists()) {
    // Remove all mipmap directories (contain old launcher icons)
    await for (final entity in androidResDir.list()) {
      if (entity is Directory) {
        final dirName = path.basename(entity.path);
        if (dirName.startsWith('mipmap-')) {
          try {
            await entity.delete(recursive: true);
            print('   ‚úÖ Removed Android mipmap: $dirName');
          } catch (e) {
            print('   ‚ö†Ô∏è  Could not remove $dirName: $e');
          }
        }
      }
    }
    
    // Remove adaptive icon foreground files
    final drawableDirs = ['drawable-mdpi', 'drawable-hdpi', 'drawable-xhdpi', 
                          'drawable-xxhdpi', 'drawable-xxxhdpi'];
    for (final drawableDir in drawableDirs) {
      final foregroundFile = File('android/app/src/main/res/$drawableDir/ic_launcher_foreground.png');
      if (await foregroundFile.exists()) {
        try {
          await foregroundFile.delete();
          print('   ‚úÖ Removed Android foreground: $drawableDir/ic_launcher_foreground.png');
        } catch (e) {
          print('   ‚ö†Ô∏è  Could not remove foreground: $e');
        }
      }
    }
  }
  
  // Clean iOS icons
  final iosAppIconDir = Directory('ios/Runner/Assets.xcassets/AppIcon.appiconset');
  if (await iosAppIconDir.exists()) {
    try {
      await for (final entity in iosAppIconDir.list()) {
        if (entity is File && path.extension(entity.path) == '.png') {
          await entity.delete();
          print('   ‚úÖ Removed iOS icon: ${path.basename(entity.path)}');
        }
      }
      // Also remove Contents.json to force regeneration
      final contentsJson = File('${iosAppIconDir.path}/Contents.json');
      if (await contentsJson.exists()) {
        await contentsJson.delete();
        print('   ‚úÖ Removed iOS Contents.json');
      }
    } catch (e) {
      print('   ‚ö†Ô∏è  Could not clean iOS icons: $e');
    }
  }
  
  print('‚úÖ Old icons cleaned');
}

Future<void> generateIOSIconContentsJson() async {
  final contentsJsonPath = 'ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json';
  final contentsJsonFile = File(contentsJsonPath);
  final iconSourcePath = 'assets/generated/icon.png';
  final iconDestPath = 'ios/Runner/Assets.xcassets/AppIcon.appiconset/icon_1024.png';

  print('üîß Setting up iOS AppIcon with single 1024x1024 image (modern approach)...');

  // Copy the downloaded 1024x1024 icon to the AppIcon.appiconset directory
  final iconSource = File(iconSourcePath);
  if (await iconSource.exists()) {
    final iconDest = File(iconDestPath);
    await iconDest.create(recursive: true);
    await iconSource.copy(iconDestPath);
    print('‚úÖ Copied 1024x1024 icon to AppIcon.appiconset');
  } else {
    print('‚ö†Ô∏è  Warning: Icon source not found at $iconSourcePath');
  }

  // Use the modern iOS approach: single 1024x1024 image
  // iOS 11+ automatically generates all required sizes from this
  final contentsJson = {
    "images": [
      {
        "filename": "icon_1024.png",
        "idiom": "universal",
        "platform": "ios",
        "size": "1024x1024"
      }
    ],
    "info": {
      "author": "xcode",
      "version": 1
    }
  };

  // Create the directory if it doesn't exist
  await contentsJsonFile.create(recursive: true);

  // Write the JSON file with proper formatting
  final encoder = JsonEncoder.withIndent('  ');
  await contentsJsonFile.writeAsString(encoder.convert(contentsJson));

  print('‚úÖ Generated iOS AppIcon Contents.json with single 1024x1024 icon');
}

Future<void> generateIconConfig() async {
  final config = '''
flutter_launcher_icons:
  android: true
  ios: false  # We handle iOS icons manually with modern single 1024x1024 approach
  image_path: "assets/generated/icon.png"
  min_sdk_android: 21
  adaptive_icon_background: "#FFFFFF"
  adaptive_icon_foreground: "assets/generated/icon.png"
''';

  final file = File('flutter_launcher_icons.yaml');
  await file.writeAsString(config);
  print('‚úÖ Generated flutter_launcher_icons.yaml (Android only)');
}

Future<void> generateSplashConfig() async {
  final config = '''
flutter_native_splash:
  background_image: "assets/generated/splash.png"
  android: true
  ios: true
  web: false
  android_12:
    background_image: "assets/generated/splash.png"
  ios_content_mode: center
  fullscreen: true
  android_gravity: center
''';

  final file = File('flutter_native_splash.yaml');
  await file.writeAsString(config);
  print('‚úÖ Generated flutter_native_splash.yaml');
}

Future<void> runFlutterLauncherIcons() async {
  try {
    // First ensure pub get is run
    await Process.run('flutter', ['pub', 'get'],
        workingDirectory: Directory.current.path);

    // Try new syntax first (dart run), fallback to old syntax
    var result = await Process.run(
      'dart',
      ['run', 'flutter_launcher_icons'],
      workingDirectory: Directory.current.path,
    );

    if (result.exitCode != 0) {
      // Fallback to old syntax
      result = await Process.run(
        'flutter',
        ['pub', 'run', 'flutter_launcher_icons'],
        workingDirectory: Directory.current.path,
      );
    }

    if (result.exitCode == 0) {
      print('‚úÖ App icons generated successfully');
    } else {
      print('‚ö†Ô∏è  Icon generation warning: ${result.stderr}');
    }
  } catch (e) {
    print('‚ö†Ô∏è  Failed to generate icons: $e');
  }
}

Future<void> runFlutterNativeSplash() async {
  try {
    // First ensure pub get is run
    await Process.run('flutter', ['pub', 'get'],
        workingDirectory: Directory.current.path);

    // Try new syntax first (dart run), fallback to old syntax
    var result = await Process.run(
      'dart',
      ['run', 'flutter_native_splash:create'],
      workingDirectory: Directory.current.path,
    );

    if (result.exitCode != 0) {
      // Fallback to old syntax
      result = await Process.run(
        'flutter',
        ['pub', 'run', 'flutter_native_splash:create'],
        workingDirectory: Directory.current.path,
      );
    }

    if (result.exitCode == 0) {
      print('‚úÖ Splash screens generated successfully');
    } else {
      print('‚ö†Ô∏è  Splash generation warning: ${result.stderr}');
    }
  } catch (e) {
    print('‚ö†Ô∏è  Failed to generate splash screens: $e');
  }
}

Future<void> buildRelease(String eventName) async {
  final buildsDir = Directory('builds/$eventName');
  await buildsDir.create(recursive: true);

  print('üì± Building Android AAB...');
  final androidResult = await Process.run(
    'flutter',
    ['build', 'appbundle', '--release'],
    workingDirectory: Directory.current.path,
  );
  if (androidResult.exitCode == 0) {
    final aabSource = File('build/app/outputs/bundle/release/app-release.aab');
    if (await aabSource.exists()) {
      final aabDest = File('builds/$eventName/${eventName}.aab');
      await aabSource.copy(aabDest.path);
      print('‚úÖ Android AAB: ${aabDest.path}');
    }
  } else {
    print('‚ö†Ô∏è  Android build failed: ${androidResult.stderr}');
  }

  print('üçé Building iOS IPA...');
  final iosResult = await Process.run(
    'flutter',
    ['build', 'ipa', '--release'],
    workingDirectory: Directory.current.path,
  );
  if (iosResult.exitCode == 0) {
    final ipaSource = File('build/ios/ipa/${eventName}.ipa');
    if (await ipaSource.exists()) {
      final ipaDest = File('builds/$eventName/${eventName}.ipa');
      await ipaSource.copy(ipaDest.path);
      print('‚úÖ iOS IPA: ${ipaDest.path}');
    }
  } else {
    print('‚ö†Ô∏è  iOS build failed: ${iosResult.stderr}');
  }
}

